<?php

include_once('bbcom_dictionary.features.inc');

/**
 * Implementation of hook_nodeapi().
 */
// Add entry summary information to the node view
function bbcom_dictionary_nodeapi(&$node, $op, $a3, $a4) {
  global $user;

  if ($op == 'view') {
    if ($node->type != LingwoEntry::$settings->content_type) {
      return NULL;
    }

    $entry = LingwoEntry::fromNode($node);

    // get the pos
    $pos = $entry->getPos();

    // get the source language
    $language = $entry->getSourceLanguage();

    // hide the fields and summary for non-admin users
    // TODO: should this be 'editor'?
    if (array_search('admin', $user->roles) == TRUE) {
      $node->content['entry_summary'] = array(
        '#weight' => -1,
        '#value'  => theme(array(
          'bbcom_dictionary_entry_summary_'. $language .'_'. $pos,
          'bbcom_dictionary_entry_summary_'. $language,
          'bbcom_dictionary_entry_summary'
        ), $node, $a3, $a4)
      );
    }
    else {
      unset($node->content['lingwo_fields']);
    }
  }
}

/**
 * Implementation of hook_block().
 */
function bbcom_dictionary_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      $blocks[0] = array(
        'info' => t('BiblioBird.com Dictionary: Add Content Block'),
      );
      return $blocks;

    case 'view':
      if ($delta == 0 && user_access('create entry content')) {
        $block['content'] = l(t('Create Dictionary Entry'), 'node/add/entry',
          array('attributes' => array('id' => 'create-content-link')));
        return $block;
      }
      break; 
  }
}

/**
 * Implementation of hook_link().
 *
 * Adds a link to an entries source entry.
 *
 */
/*
function bbcom_dictionary_link($type, $node, $teaser=FALSE) {
  if ($type == 'node' && $node->type == LingwoEntry::$settings->content_type &&
      ($source_node = lingwo_dictionary_entry_load_translation_source($node))) {
    
    $languages = language_list();
    $language_name = $languages[$source_node->language]->name;
    return array(
      'bbcom_dictionary-source' => array(
        'title' => t('Source entry in @lang', array('@lang' => $language_name)),
        'href'  => lingwo_dictionary_entry_path($source_node),
      )
    );
  }
}
*/

/**
 * Implementation of hook_field_formatter_info().
 */
function bbcom_dictionary_field_formatter_info() {
  return array(
    'text_link' => array(
      'label' => t('Link'),
      'field types' => array('text')
    ),
    'text_pre' => array(
      'label' => t('Pre'),
      'field types' => array('text')
    ),
  );
}

/**
 * Implementation of hook_theme().
 */
function bbcom_dictionary_theme() {
  return array(
    'bbcom_dictionary_entry_summary' => array(
      'arguments' => array('node' => NULL, 'teaser' => FALSE, 'page' => FALSE),
      'pattern' => 'bbcom_dictionary_entry_summary_',
    ),
    'bbcom_dictionary_formatter_text_link' => array(
      'arguments' => array('element' => NULL),
    ),
    'bbcom_dictionary_formatter_text_pre' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

function template_preprocess_bbcom_dictionary_entry_summary(&$vars, $hook) {
  $node = $vars['node'];
  $entry = LingwoEntry::fromNode($node);

  // TODO: we need to get some "human" readable versions of the pos as well,
  // including the translations for other languages.
  $vars['pos'] = $entry->getPos();

  $translation_source = $entry->getTranslationSource();
  $vars['source_node'] = $translation_source ? $translation_source : $node;
  $vars['source_lang'] = $vars['source_node']->language;
  $vars['is_translation'] = _lingwo_is_translation($node);

  // get the source fields (we always deal with the source fields, so this should be
  // no surprise and we can name it simply $fields).
  $vars['fields'] = lingwo_fields_map_items($vars['source_node']->lingwo_fields);
}

function theme_bbcom_dictionary_entry_summary($node, $teaser=FALSE, $page=FALSE) {
  // TODO: is there some default that makes sense?
  return '';
}

function theme_bbcom_dictionary_formatter_text_link($element) {
  // we cheat by calling the default formatter first
  $value = theme('text_formatter_default', $element);
  return l($value, $value);
}

function theme_bbcom_dictionary_formatter_text_pre($element) {
  // we cheat by calling the default formatter first
  $value = theme('text_formatter_default', $element);
  // TODO: I'm not sure if this is the right thing to do..  Do we want a semantic <pre>?
  // Which to me goes in the middle of an article, like <p>, <p>, let me hit you with
  // some <pre>, then <p>, <p>.  It serves a totally different purpose than this..
  return '<div style="white-space: pre;">'. trim($value) .'</div>';
}


